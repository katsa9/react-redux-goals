<!DOCTYPE html>
<html>

<head>
  <title>My Todos Goals</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
  <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  <script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script>
  <!-- mock server -->
  <script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
</head>

<body>
  <div id="app"></div>


  <!-- Doing this on purpose -->
  <script type="text/javascript">
    function generateId() {
      return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
    }

    const ADD_TODO = 'ADD_TODO'
    const REMOVE_TODO = 'REMOVE_TODO'
    const TOGGLE_TODO = 'TOGGLE_TODO'
    const ADD_GOAL = 'ADD_GOAL'
    const REMOVE_GOAL = 'REMOVE_GOAL'
    const RECEIVE_DATA = 'RECEIVE_DATA'

    function receiveDataAction (todos, goals) {
      return {
        type: RECEIVE_DATA,
        todos,
        goals,
      }
    }

    function handleInitialData() {
      return (dispatch) => {
        return Promise.all([
          API.fetchTodos(),
          API.fetchGoals()
        ]).then(([ todos, goals ]) => {
          dispatch(receiveDataAction(todos,goals))
          console.log('Todos', todos)
          console.log('Goals', goals)
        })
      }
    }

    function handleAddTodo(name, callback) {
      return (dispatch) => {
        return API.saveTodo(name)
          .then((todo) => {
            dispatch(addTodoAction(todo))
            callback()
          })
          .catch(() => {
            alert('There was an error. Try again.')
          })
      }
    }

    function handleDeleteTodo(todo) {
      return (dispatch) => {
        dispatch(removeTodoAction(todo.id))
        return API.deleteTodo(todo.id)
          .catch(() => {
            dispatch(addTodoAction(todo))
            alert("There was an error. Try again")
          })
      }
    }

    function handleToggleTodo(id) {
      return (dispatch) => {
        dispatch(toggleTodoAction(id)) //optimistic updating of ui
        return API.saveTodoToggle()
          .catch(() => {
            dispatch(toggleTodoAction(id)) //resets value to original if there was an error
            alert("There was an error. Try again")
          })
      }
    }

    function handleAddGoal(name, callback) {
      return (dispatch) => {
        return API.saveGoal(name)
          .then((goal) => {
            dispatch(addGoalAction(goal))
            callback()
          })
          .catch(() => alert("There was an error. Try again."))
      }
    }

    function handleDeleteGoal(goal) {
      return (dispatch) => {
       dispatch(removeGoalAction(goal.id))
       return API.deleteGoal(goal.id)
          .catch(() => {
            dispatch(addGoalAction(goal))
            alert("An error occurred. Try again")
          })
      }
    }

    function addTodoAction(todo) {
      return {
        type: ADD_TODO,
        todo,
      }
    }

    function removeTodoAction(id) {
      return {
        type: REMOVE_TODO,
        id,
      }
    }

    function toggleTodoAction(id) {
      return {
        type: TOGGLE_TODO,
        id,
      }
    }

    function addGoalAction(goal) {
      return {
        type: ADD_GOAL,
        goal,
      }
    }

    function removeGoalAction(id) {
      return {
        type: REMOVE_GOAL,
        id,
      }
    }

    //ES6 version of checker
    const checker = (store) => (next) => (action) => {
      if (action.type === ADD_TODO && action.todo.name.toLowerCase().includes("bitcoin")) {
        return alert("Nope, thats a bad idea");
      }
      if (action.type === ADD_GOAL && action.goal.name.toLowerCase().includes("bitcoin")) {
        return alert("Nope, thats a bad idea");
      }
      return next(action)
    }
    //create middleware function
    // function checker(store) {
    //     return function (next) { //next middleware call if there is one else dispatch will be passed in
    //       return function (action) {
    //         if (action.type === ADD_TODO && action.todo.name.toLowerCase().includes("bitcoin")) {
    //           return alert("Nope, thats a bad idea");
    //         }
    //         if (action.type === ADD_GOAL && action.goal.name.toLowerCase().includes("bitcoin")) {
    //           return alert("Nope, thats a bad idea");
    //         }
    //         return next(action);
    //       }
    //     }
    //   }

    const logger = (store) => (next) => (action) => {
      console.group(action.type)
      console.log('The action: ', action)
      const result = next(action) //calling dispatch
      console.log('The new state is: ', store.getState())
      console.groupEnd()
      return result
    }
    //App Code
    //Need a reducer for each piece of state
    function todos(state = [],
      action) { //this is called a reducer - reduces the current state and the action to the new state
      switch (action.type) {
        case ADD_TODO:
          return state.concat([action.todo]);
        case REMOVE_TODO:
          return state.filter((todo) => todo.id !== action.id);
        case TOGGLE_TODO:
          return state.map((todo) => todo.id !== action.id ? todo :
            Object.assign({}, todo, {
              complete: !todo.complete     //updates property on object in array
            }));
        case RECEIVE_DATA:
          return action.todos    
        default:
          return state;
      }
    }

    function goals(state = [], action) {
      switch (action.type) {
        case ADD_GOAL:
          return state.concat([action.goal]);
        case REMOVE_GOAL:
          return state.filter((goal) => goal.id !== action.id);
        case RECEIVE_DATA:
          return action.goals;
        default:
          return state;
      }
    }
//reducer
    function loading (state = true, action) {
      switch(action.type) {
        case RECEIVE_DATA :
          return false
        default :
          return state
      }
    }
    //Creating the store with Redux - pass object in with reducers as well as middleware
    //middleware functions called in order they are passed in
    const store = Redux.createStore(Redux.combineReducers({
      todos,
      goals,
      loading
    }), Redux.applyMiddleware(ReduxThunk.default, checker, logger)) 
    /**
     Thunk is middleware allows us to have action creators that return functions that take in dispatch as an argument. This allows us to have have action creators be the ones in charge of calling the API. 
     This keeps the UI code clean and keeps the data logic separate.
    What thunk does is it checks if the action type is funcion then it invokes the action and passes it dispatch. Otherwise it just invokes next()

    **/
  </script>
  
  <script type='text/babel'>
    function List(props) {
      return (
        <ul>
          {props.items.map((item) => (
            <li key={item.id}>
              <span 
                onClick={() => props.toggle && props.toggle(item.id)}
                style={{textDecoration: item.complete ? 'line-through' : 'none'}}>
                {item.name}
              </span>
              <button onClick={() => props.remove(item)}>
               X  
              </button>
            </li>
          ))}
        </ul>
      )
    }

    class Todos extends React.Component {

      addItem = (event) => {
        event.preventDefault()
        this.props.dispatch(handleAddTodo(
          this.input.value,
          () => this.input.value = ''))
      }

      removeItem = (todo) => {
        this.props.dispatch(handleDeleteTodo(todo))
      }

      toggleItem = (id) => {
        this.props.dispatch(handleToggleTodo(id))
      }

      render() {
        return (
          <div>
           <h1>Todo List</h1>
           <input type='text'
              placeholder="Add todo"
              ref={(input) => this.input = input} />
              <button onClick={this.addItem}>Add Todo</button>
            <List 
              items={this.props.todos}
              remove={this.removeItem}
              toggle={this.toggleItem}
            />
          </div>
        )
      }
    }

    class ConnectedTodos extends React.Component {
      render() {
        return (
          <Context.Consumer>
            {(store) => {
              const {todos} = store.getState()
              return <Todos todos={todos} dispatch={store.dispatch}/>
            }}
          </Context.Consumer>  
        )
      }
    }

    class Goals extends React.Component {

      addItem = (event) => {
        event.preventDefault()
        this.props.dispatch(handleAddGoal(
          this.input.value, 
          () => this.input.value = '') //callback allows us to update the input ui element from our action creator.
          )
      }

      removeItem = (goal) => {
        this.props.dispatch(handleDeleteGoal(goal))
      }

      render() {
        return (
          <div>
            <h1>Goals List</h1>
              <input type='text'
                placeholder="Add goal"
                ref={(input) => this.input = input} />
              <button onClick={this.addItem}>Add Goal</button>
            <List 
              items={this.props.goals}
              remove={this.removeItem}
              />
          </div>
        )
      }
    }

    class ConnectedGoals extends React.Component {
      render() {
        return (
          <Context.Consumer >
            {(store) => {
              const {goals} = store.getState()
              return <Goals goals={goals} dispatch={store.dispatch}/>
            }}
          </Context.Consumer>  
        )
      }
    }


    //FOR REFERENCE
    // * connect function takes in a dunction that maps the state to the props that you want
    //for the component passed in. Then in the render method the
    // spread operator spreads thereturned object so that 
    //each field in the object becomes a prop on the component.

    function connect(mapStateToProps) {
        return (Component) => {
            class Receiver extends React.Component {
                componentDidMount() {
                    const {subscribe} = this.props.store;
                    this.unsubscribe = subscribe(() =>{
                        this.forceUpdate();
                    })
                }
                componentWillUnmount(){
                    this.unsubscribe();
                }
                render() {
                    const {dispatch, getState } = this.props.store;
                    const state = getState();
                    const stateNeeded = mapStateToProps(state);
                    return <Component {...stateNeeded} dispatch={dispatch}/>
                }
            }
            class ConnectedComponent extends React.Component {
                render() {
                    return (
                        <Context.Consumer>
                            {store => <Receiver store={store}/>}
                        </Context.Consumer>
                    )
                }
            }
            return ConnectedComponent;
        }
    }


  class App extends React.Component {

    componentDidMount () {
      const { store } = this.props
      store.dispatch(handleInitialData())
      store.subscribe(() => this.forceUpdate())
      }

    render() {
      const { store } = this.props
      const { loading } = store.getState()
      
      if (loading === true) {
          return <h3>Loading</h3>
      }

      return (
        <div>
          <ConnectedTodos />
          <ConnectedGoals />
        </div>
      )
    }
  }
// Connected component responsible for getting the store off the context
  class ConnectedApp extends React.Component {
    render() {
      return (
        <Context.Consumer>
          {(store) => (
            <App store={store} />
          )}
        </Context.Consumer>  
      )
    }
  }

  const Context = React.createContext()

  class Provider extends React.Component {
    render() {
      return (
        <Context.Provider value={this.props.store}>
          {this.props.children}
        </Context.Provider>  
      )
    }
  }

  ReactDOM.render(
    <Provider store={store}>
      <ConnectedApp />
    </Provider>,
    document.getElementById('app')
  )
  
  </script>
</body>